// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Approval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Approval entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Approval entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Approval", id.toString(), this);
  }

  static load(id: string): Approval | null {
    return store.get("Approval", id) as Approval | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class Claim extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Claim entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Claim entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Claim", id.toString(), this);
  }

  static load(id: string): Claim | null {
    return store.get("Claim", id) as Claim | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestedAmount(): BigInt {
    let value = this.get("requestedAmount");
    return value.toBigInt();
  }

  set requestedAmount(value: BigInt) {
    this.set("requestedAmount", Value.fromBigInt(value));
  }

  get claimedAmount(): BigInt {
    let value = this.get("claimedAmount");
    return value.toBigInt();
  }

  set claimedAmount(value: BigInt) {
    this.set("claimedAmount", Value.fromBigInt(value));
  }

  get feeAmount(): BigInt {
    let value = this.get("feeAmount");
    return value.toBigInt();
  }

  set feeAmount(value: BigInt) {
    this.set("feeAmount", Value.fromBigInt(value));
  }

  get burnedAmount(): BigInt {
    let value = this.get("burnedAmount");
    return value.toBigInt();
  }

  set burnedAmount(value: BigInt) {
    this.set("burnedAmount", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class StrategyUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save StrategyUpdate entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StrategyUpdate entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("StrategyUpdate", id.toString(), this);
  }

  static load(id: string): StrategyUpdate | null {
    return store.get("StrategyUpdate", id) as StrategyUpdate | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get perBlockReward(): BigInt {
    let value = this.get("perBlockReward");
    return value.toBigInt();
  }

  set perBlockReward(value: BigInt) {
    this.set("perBlockReward", Value.fromBigInt(value));
  }

  get startBlockNumber(): BigInt {
    let value = this.get("startBlockNumber");
    return value.toBigInt();
  }

  set startBlockNumber(value: BigInt) {
    this.set("startBlockNumber", Value.fromBigInt(value));
  }

  get endBlockNumber(): BigInt {
    let value = this.get("endBlockNumber");
    return value.toBigInt();
  }

  set endBlockNumber(value: BigInt) {
    this.set("endBlockNumber", Value.fromBigInt(value));
  }
}

export class FeeClaimed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save FeeClaimed entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save FeeClaimed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("FeeClaimed", id.toString(), this);
  }

  static load(id: string): FeeClaimed | null {
    return store.get("FeeClaimed", id) as FeeClaimed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class Migrated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Migrated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Migrated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Migrated", id.toString(), this);
  }

  static load(id: string): Migrated | null {
    return store.get("Migrated", id) as Migrated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get omTokenV1StakeAmount(): BigInt {
    let value = this.get("omTokenV1StakeAmount");
    return value.toBigInt();
  }

  set omTokenV1StakeAmount(value: BigInt) {
    this.set("omTokenV1StakeAmount", Value.fromBigInt(value));
  }

  get stakingPoolV1Reward(): BigInt {
    let value = this.get("stakingPoolV1Reward");
    return value.toBigInt();
  }

  set stakingPoolV1Reward(value: BigInt) {
    this.set("stakingPoolV1Reward", Value.fromBigInt(value));
  }

  get stakingPoolV2Reward(): BigInt {
    let value = this.get("stakingPoolV2Reward");
    return value.toBigInt();
  }

  set stakingPoolV2Reward(value: BigInt) {
    this.set("stakingPoolV2Reward", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class NextStrategyRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NextStrategyRemoved entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NextStrategyRemoved entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NextStrategyRemoved", id.toString(), this);
  }

  static load(id: string): NextStrategyRemoved | null {
    return store.get("NextStrategyRemoved", id) as NextStrategyRemoved | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class NextStrategyUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NextStrategyUpdated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NextStrategyUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NextStrategyUpdated", id.toString(), this);
  }

  static load(id: string): NextStrategyUpdated | null {
    return store.get("NextStrategyUpdated", id) as NextStrategyUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get perBlockReward(): BigInt {
    let value = this.get("perBlockReward");
    return value.toBigInt();
  }

  set perBlockReward(value: BigInt) {
    this.set("perBlockReward", Value.fromBigInt(value));
  }

  get startBlockNumber(): BigInt {
    let value = this.get("startBlockNumber");
    return value.toBigInt();
  }

  set startBlockNumber(value: BigInt) {
    this.set("startBlockNumber", Value.fromBigInt(value));
  }

  get endBlockNumber(): BigInt {
    let value = this.get("endBlockNumber");
    return value.toBigInt();
  }

  set endBlockNumber(value: BigInt) {
    this.set("endBlockNumber", Value.fromBigInt(value));
  }
}

export class PoolIncreased extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save PoolIncreased entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PoolIncreased entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PoolIncreased", id.toString(), this);
  }

  static load(id: string): PoolIncreased | null {
    return store.get("PoolIncreased", id) as PoolIncreased | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    return value.toBytes();
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class PriceUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save PriceUpdated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PriceUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PriceUpdated", id.toString(), this);
  }

  static load(id: string): PriceUpdated | null {
    return store.get("PriceUpdated", id) as PriceUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get base(): BigInt {
    let value = this.get("base");
    return value.toBigInt();
  }

  set base(value: BigInt) {
    this.set("base", Value.fromBigInt(value));
  }

  get mantissa(): BigInt {
    let value = this.get("mantissa");
    return value.toBigInt();
  }

  set mantissa(value: BigInt) {
    this.set("mantissa", Value.fromBigInt(value));
  }

  get exponentiation(): BigInt {
    let value = this.get("exponentiation");
    return value.toBigInt();
  }

  set exponentiation(value: BigInt) {
    this.set("exponentiation", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class RewardsUnlocked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RewardsUnlocked entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RewardsUnlocked entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RewardsUnlocked", id.toString(), this);
  }

  static load(id: string): RewardsUnlocked | null {
    return store.get("RewardsUnlocked", id) as RewardsUnlocked | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class Staked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Staked entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Staked entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Staked", id.toString(), this);
  }

  static load(id: string): Staked | null {
    return store.get("Staked", id) as Staked | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    return value.toBytes();
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get stakedAmount(): BigInt {
    let value = this.get("stakedAmount");
    return value.toBigInt();
  }

  set stakedAmount(value: BigInt) {
    this.set("stakedAmount", Value.fromBigInt(value));
  }

  get mintedAmount(): BigInt {
    let value = this.get("mintedAmount");
    return value.toBigInt();
  }

  set mintedAmount(value: BigInt) {
    this.set("mintedAmount", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Transfer entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Transfer entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Transfer", id.toString(), this);
  }

  static load(id: string): Transfer | null {
    return store.get("Transfer", id) as Transfer | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class Unstaked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Unstaked entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unstaked entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unstaked", id.toString(), this);
  }

  static load(id: string): Unstaked | null {
    return store.get("Unstaked", id) as Unstaked | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get requestedAmount(): BigInt {
    let value = this.get("requestedAmount");
    return value.toBigInt();
  }

  set requestedAmount(value: BigInt) {
    this.set("requestedAmount", Value.fromBigInt(value));
  }

  get unstakedAmount(): BigInt {
    let value = this.get("unstakedAmount");
    return value.toBigInt();
  }

  set unstakedAmount(value: BigInt) {
    this.set("unstakedAmount", Value.fromBigInt(value));
  }

  get burnedAmount(): BigInt {
    let value = this.get("burnedAmount");
    return value.toBigInt();
  }

  set burnedAmount(value: BigInt) {
    this.set("burnedAmount", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class UnstakingTimeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UnstakingTimeUpdated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UnstakingTimeUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UnstakingTimeUpdated", id.toString(), this);
  }

  static load(id: string): UnstakingTimeUpdated | null {
    return store.get("UnstakingTimeUpdated", id) as UnstakingTimeUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get unstakingTime(): BigInt {
    let value = this.get("unstakingTime");
    return value.toBigInt();
  }

  set unstakingTime(value: BigInt) {
    this.set("unstakingTime", Value.fromBigInt(value));
  }
}

export class Withdrawed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Withdrawed entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Withdrawed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Withdrawed", id.toString(), this);
  }

  static load(id: string): Withdrawed | null {
    return store.get("Withdrawed", id) as Withdrawed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get price(): i32 {
    let value = this.get("price");
    return value.toI32();
  }

  set price(value: i32) {
    this.set("price", Value.fromI32(value));
  }
}

export class SwapTokensForExactTokens extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save SwapTokensForExactTokens entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save SwapTokensForExactTokens entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("SwapTokensForExactTokens", id.toString(), this);
  }

  static load(id: string): SwapTokensForExactTokens | null {
    return store.get(
      "SwapTokensForExactTokens",
      id
    ) as SwapTokensForExactTokens | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amountOut(): BigInt {
    let value = this.get("amountOut");
    return value.toBigInt();
  }

  set amountOut(value: BigInt) {
    this.set("amountOut", Value.fromBigInt(value));
  }

  get amountInMax(): BigInt {
    let value = this.get("amountInMax");
    return value.toBigInt();
  }

  set amountInMax(value: BigInt) {
    this.set("amountInMax", Value.fromBigInt(value));
  }

  get deadline(): BigInt {
    let value = this.get("deadline");
    return value.toBigInt();
  }

  set deadline(value: BigInt) {
    this.set("deadline", Value.fromBigInt(value));
  }
}

export class EthUsdSync extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save EthUsdSync entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save EthUsdSync entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("EthUsdSync", id.toString(), this);
  }

  static load(id: string): EthUsdSync | null {
    return store.get("EthUsdSync", id) as EthUsdSync | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get eth(): BigInt {
    let value = this.get("eth");
    return value.toBigInt();
  }

  set eth(value: BigInt) {
    this.set("eth", Value.fromBigInt(value));
  }

  get usd(): BigInt {
    let value = this.get("usd");
    return value.toBigInt();
  }

  set usd(value: BigInt) {
    this.set("usd", Value.fromBigInt(value));
  }
}

export class EthOmSync extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save EthOmSync entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save EthOmSync entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("EthOmSync", id.toString(), this);
  }

  static load(id: string): EthOmSync | null {
    return store.get("EthOmSync", id) as EthOmSync | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get eth(): BigInt {
    let value = this.get("eth");
    return value.toBigInt();
  }

  set eth(value: BigInt) {
    this.set("eth", Value.fromBigInt(value));
  }

  get om(): BigInt {
    let value = this.get("om");
    return value.toBigInt();
  }

  set om(value: BigInt) {
    this.set("om", Value.fromBigInt(value));
  }
}

export class MantraDaoDayData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MantraDaoDayData entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MantraDaoDayData entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MantraDaoDayData", id.toString(), this);
  }

  static load(id: string): MantraDaoDayData | null {
    return store.get("MantraDaoDayData", id) as MantraDaoDayData | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get date(): i32 {
    let value = this.get("date");
    return value.toI32();
  }

  set date(value: i32) {
    this.set("date", Value.fromI32(value));
  }

  get totalLiquidityUSD(): BigInt {
    let value = this.get("totalLiquidityUSD");
    return value.toBigInt();
  }

  set totalLiquidityUSD(value: BigInt) {
    this.set("totalLiquidityUSD", Value.fromBigInt(value));
  }

  get totalLiquidityOM(): BigInt {
    let value = this.get("totalLiquidityOM");
    return value.toBigInt();
  }

  set totalLiquidityOM(value: BigInt) {
    this.set("totalLiquidityOM", Value.fromBigInt(value));
  }

  get txCount(): BigInt {
    let value = this.get("txCount");
    return value.toBigInt();
  }

  set txCount(value: BigInt) {
    this.set("txCount", Value.fromBigInt(value));
  }
}
